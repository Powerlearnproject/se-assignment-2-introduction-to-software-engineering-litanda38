1. What is software engineering, and how does it differ from traditional programming?

Software engineering is a systematic approach to developing, deploying, and maintaining software applications. It combines computer science principles with engineering practices to ensure:

High-quality software: Reliable, efficient, secure, and meets user needs.
Efficient development process: Predictable development time and cost.
Maintainability: Easy to understand, modify, and fix bugs.
Traditional programming focuses on writing code to achieve a specific functionality. It often lacks a structured approach for design, documentation, testing, and maintaining the software. Here's a table summarizing the key differences:

Feature	Software Engineering	Traditional Programming
Focus	Entire software lifecycle (planning, requirements, design, development, testing, deployment, maintenance)	Writing code to achieve specific functionality
Approach	Structured and methodical using frameworks like SDLC	Less structured, may lack formal planning and documentation
Maintainability & Scalability	Prioritizes maintainability and scalability for future modifications	Code might be difficult to understand and modify later
Team Approach	Team-oriented, with engineers collaborating on complex systems	Often an individual activity for smaller projects

drive_spreadsheet
Export to Sheets
Analogy: Building a house is like software engineering. You have a blueprint, plan materials, follow a construction process, and ensure a structurally sound final product. Traditional programming is like focusing only on hammering nails and putting up walls without a plan.

2. Explain the various phases of the Software Development Life Cycle (SDLC). Provide a brief description of each phase.

The SDLC is a framework that defines the stages involved in software development. Here's a breakdown of the common phases:

Planning and Requirements Gathering: Understanding stakeholder needs, defining functionalities, and creating a Software Requirements Specification (SRS) document.
System Design: Designing the software architecture based on the requirements, including components, interactions, and data flow.
Development: Writing code based on the design specifications and following coding standards for quality and maintainability.
Testing: Identifying and fixing bugs through various levels of testing (unit, integration, system, and acceptance testing).
Deployment: Releasing the software to users, including creating installation packages, server deployment, and user training.
Maintenance: Fixing bugs, adding new features, and updating the software throughout its lifecycle.
3. Agile vs. Waterfall Models

There are different SDLC models that define the order and interaction of these phases. Here's a comparison of two popular models:

Waterfall Model:

Sequential approach: Each phase is completed one after another before moving to the next.
Benefits: Clear planning, well-defined requirements, and easy progress tracking.
Drawbacks: Inflexible to changes in requirements after the initial stages. Development cycles can be lengthy.
Agile Model:

Iterative and incremental approach: Requirements are broken down into user stories. The software is developed and tested in short cycles (sprints) with continuous feedback and adaptation.
Benefits: Faster delivery of working features, adaptable to changes, and incorporates user feedback throughout the process.
Drawbacks: Increased complexity in managing multiple iterations. Requires strong team collaboration and communication.
Choosing the right model depends on various factors:

Project size and complexity: Waterfall might be suitable for smaller projects with well-defined requirements. Agile is better for larger, evolving projects.
Project risk and uncertainty: Agile is better suited for projects with high uncertainty or changing requirements.
Team structure and culture: Agile requires strong communication and collaboration within the development team.
4. What is requirements engineering? Describe the process and its importance in the software development lifecycle.

Requirements engineering is the process of gathering, analyzing, documenting, and validating user needs and system functionalities. It's crucial for several reasons:

Ensures the software meets user expectations. Clear requirements prevent misunderstandings and rework due to unclear needs.
Reduces development rework due to unclear requirements. Having a documented baseline reduces the risk of building the wrong product.
Provides a basis for testing and evaluation. Defined requirements serve as a benchmark to measure if the software meets its intended goals.
Process:

Elicit requirements: Through interviews, surveys, and user stories to understand user needs.
Analyze and refine: Ensure clarity, completeness, and consistency of requirements.
Document requirements: Create a formal document (Software Requirements Specification - SRS).
Validate requirements: Verify requirements are understood and meet user needs through reviews and demonstrations.

6. Levels of Software Testing:

Unit Testing: Evaluating individual units of code (functions, modules) for correctness.
Integration Testing: Testing how different units interact with each other.
System Testing: Testing the entire software system as a whole to ensure it meets requirements.
Acceptance Testing: Verifying if the software meets user needs and acceptance criteria.
Testing is crucial to identify and fix bugs early, prevent regressions (reintroducing bugs), ensure quality, and boost user confidence.

7. Version Control Systems (VCS):

VCS are tools that track changes to code over time. They allow:

Version history: See past versions and revert if needed.

Collaboration: Multiple developers can work on the same codebase.

Branching and merging: Create isolated code variations and integrate them back.

Popular VCS: Git, Subversion (SVN)

8. Software Project Manager:

A project manager oversees all aspects of software development, including:

Responsibilities: Planning, scheduling, resource allocation, budget control, risk management, communication, team leadership.
Challenges: Meeting deadlines, managing scope creep (unplanned features), communication breakdowns, resource constraints.
9. Software Maintenance:

Definition: Modifying and updating software after release to address bugs, improve functionality, or adapt to changes.
Types:
Corrective: Fixing bugs.
Adaptive: Adding new features or adapting to changes (environment, user needs).
Perfective: Enhancing performance, usability, or security.
Maintenance is essential because software is rarely perfect at launch and needs ongoing support to remain functional and relevant.
10. Ethical Issues for Software Engineers:

Privacy: Protecting user data.
Security: Building secure software to prevent vulnerabilities.
Intellectual Property (IP): Respecting copyrights and licenses.
Bias: Avoiding creating software with discriminatory biases.
Adhering to Ethics:

Professional codes of conduct: Following guidelines set by professional organizations.
Critical thinking: Questioning potential ethical concerns in projects.
Communication: Raising ethical concerns with managers and colleagues.